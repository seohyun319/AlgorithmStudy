## 삽입 정렬 (Insertion Sort)

**💗 삽입 정렬 개념**

- 데이터를 하나씩 확인하면서 각 데이터를 적절한 위치에 **삽입**하는 개념
- 필요할 때만 위치를 바꾸기 때문에 데이터가 거의 정렬되어 있을 때 효율적

**💗 삽입 정렬 예시**

- 7 5 9 0 (오름차순으로 정렬하기)
    1. 첫 번째 데이터 7은 그 자체로 정렬되어 있다고 판단하고 5가 어떤 위치로 들어갈지 판단한다. 이때 7의 왼쪽으로 들어가거나 오른쪽으로 들어가는 경우만 존재한다. 따라서
        
        5 7 9 0 
        
    2. 9가 어디에 들어갈지 판단. 삽입될 수 있는 위치는 총 3가지. 제일 크기 때문에 원래의 위치에 그대로 둔다.
        
        5 7 9 0
        
    3. 0이 어디에 들어갈지 판단. 가장 작기 때문에 처음으로 보내기.
        
        0 5 7 9
        
    
    **즉, 적절한 위치에 삽입하는 과정을 n-1번 반복하게 되면 모든 데이터가 정렬 가능!**
    
    맨 왼쪽에서부터 한 칸씩 탐색하다가 자기보다 작으면 이후의 데이터를 살펴보지 않고 그 자리에 삽입된다.
    

**💗 삽입 정렬로 줄 세우기**

1. 학생이 열 명 모인 운동장에 선생님이 제일 앞에 있던 승규에게 나와서 줄을 서라고 함. 
    
    ▶ 학생 9명
    
2. 선생님이 준호에게 키를 맞춰 줄을 서라고 함. 
    
    준호 < 승규
    
    ▶ 학생 8명
    
3. 민성이에게 키를 맞춰 줄을 서라고 함.
    
    준호 < 승규 < 민성 (삽입)
    
    ▶ 학생 7명
    

**즉,  학생을 한 명씩 뽑아서 줄을 선 학생 사이사이에 키를 맞춰 끼어넣는 정렬 방식**

**💗 삽입 정렬 Solution 1**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/85e2b808-0a89-48c3-8bb8-ad0eaaf26dd7/Untitled.png)

1. 리스트 a 에 자료가 남아 있다면 >> while a
2. 남은 자료 중에 맨 앞의 값을 뽑아내기 >> value = a.pop(0)
3. 그 값이 새로 만든 result 리스트 어디에 들어가야 할지 알아냄 >> ins_idx = find_ins_idx(result, value)
4. 3번 과정에서 찾아낸 위치에 뽑아낸 값을 삽입 >> result.insert(ins_idx, value)
5. 1번으로 돌아가서 자료가 없어질 때까지 반복

이 방식은 삽입 정렬의 의미론적 이해를 돕기 위한 예제로 사용

**💗 삽입 정렬 Solution 2**

- 일반적인 삽입 정렬 개념
    1. 새롭게 삽입될 값을 미리 저장해 둠
    2. 삽입될 값이 삽입될 위치까지 리스트에 있는 값이 한 칸씩 이동
    3. 해당 자리에 저장된 값 삽입
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/46b534f5-e509-476b-874e-a34465719c4c/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3da35afb-10b5-4fe4-a1ad-26692d885c3c/Untitled.png)

1. 리스트의 i번째 값을 삽입 >> key = a[i]
2. 삽입될 값보다 크면 오른쪽으로 한 칸씩 옮김 >> while j ≥ 0 and a[j] > key: a[j+1] = a[j]
3. 찾은 삽입 위치에 key를 저장 >> a[j + 1] = key

**💗 삽입 정렬의 시간 복잡도**

- 보통: **O(N*N)**
- 이유: 반복문이 2번 중첩되어 사용되었기 때문
- But 선택 정렬과는 다르게, 데이터가 거의 정렬되어 있는 **최선의 경우**에는 **O(N)**

---

## 병합 정렬 (Merge Sort)

**💗 병합 정렬 개념**

- 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법

**💗 병합 정렬로 줄 세우기**

1. 학생을 반으로 나눠 두 집단으로 나누기
2. 각 집단을 키 순으로 정렬하기
3. 키 순으로 정렬된 각 집단의 맨 앞 학생을 비교하고 더 작은 학생을 뽑아 새로운 줄에 추가
4. 만약 한 집단의 학생이 모두 뽑히면, 남은 다른 집단의 학생 모두를 새로운 줄에 이어 붙이기

**💗 병합 정렬 Solution 1**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/200b9d7b-e69c-47c5-8fa2-91bb348ebdeb/Untitled.png)

1. 중간을 기준으로 두 그룹으로 나눔 >> mid = n // 2
2. 두 그룹에 모두 자료가 남아 있는 동안 반복 >> while g1 and g2:
3. 두 그룹의 맨 앞 자료 값을 비교 >> if g1[0] < g2[0]:
4. result.append(g1.pop(0)) >> g1의 값이 더 작으면 그 값을 빼내어 결과로 추가
5. result.append(g2.pop(0)) >> g2의 값이 더 작으면 그 값을 빼내어 결과로 추가
6. result = result + g1 + g2 >> g1 또는 g2에 남은 값을 모두 이어 붙임
7. if n ≤ 1: return a >> 재귀 종료 조건

**💗 병합 정렬 시간 복잡도**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/00b9388c-0688-405c-8335-8afb0a1d7388/Untitled.png)

- O(NlogN)
- 밑이 2인 logN만큼 반복해야 크기가 1인 배열로 분할 가능. 왜냐하면 **1/2**씩 쪼개진 배열을 합치기 때문이다.
- 그 각각의 단계에서 데이터의 개수만큼 크기를 비교하는 연산이 필요하기 때문에 최대 **n번**
의 비교 연산을 하게 된다.
- 최악과 최선 모두 같은 시간 복잡도를 가진다.

💗 **분할 정복 (Divide and Conquer)**

- 분할 정복은 주어진 문제를 절반으로 나눈 다음 각각을 재귀 호출로 풀어 가는 방식이다.
- 입력 크기가 커서 풀기 어려웠던 문제를 반복해서 나누면 종료 조건이 되는 원리를 이용했다.

**💗 병합 정렬 (Merge Sort) Solution 2**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fca3fc01-75aa-4d72-ac5d-fac4e9842b87/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bb5880b6-5266-4f4a-a66a-050b45f0fbcd/Untitled.png)

**💗 교수님 질문**

- 멀티 코어일 때 merge sort의 시간 복잡도는?
- 내림차순 정렬로 바꾸려면?
- [2, 5, 6, 3, 1] 병합 정렬하는 과정
