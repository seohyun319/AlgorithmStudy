# 중간고사 범위

## 알고리즘의 기초
- 1부터 n까지 연속한 정수의 합을 구하는 알고리즘

  ```python
  def sum_n(n):
    s = 0
    for i in range(1, n + 1):
      s = s + i
    return s
  ```
  
  1부터 n까지의 합 = n x (n+1) / 2 (수식으로 정리)
  ```python
  def sum_n(n):
    return (n * (n + 1)) // 2
  ```
  재귀
  ```python
  def sum_n(n):
    if n == 0:
      return 0
    return sum_n(n - 1) + n
  ```
  
- 주어진 숫자 n개 중 가장 큰 숫자를 찾는 알고리즘
  ```python
  def find_max(a):
    n = len(a) 
    max_v = a[0] 
    for i in range(1, n):
      if a[i] > max_v: 
      max_v = a[i]
    return max_v
  ```
  재귀
  ```python
  def find_max(a, n): # 리스트 a의 앞부분 n개 중 최댓값을 구하는 재귀 함수
    if n == 1:
      return a[0]
    max_n_1 = find_max(a, n - 1) # n-1개 중 최댓값을 구함
    if max_n_1 > a[n - 1]: # n-1개 중 최댓값과 n-1번 위치 값을 비교
      return max_n_1
    else:
      return a[n - 1]
  ```

- 1부터 n까지 연속한 정수의 곱을 구하는 알고리즘

  ```python
  def fact(n):
    f = 1 
    for i in range(1, n + 1): 
      f = f * i
      return f
    ```
  재귀함수 이용
  ```python
  def fact(n):
    if n <= 1: #종료조건
      return 1
    return n * fact(n - 1)
  ```
- 하노이의 탑
  ```python
  def Hanoi(N, from_pos, to_pos, via_pos):
    if N == 1:
      print( from_pos, "번 기둥에 있는 원반을 ", to_pos, "번 기둥으로 옮긴다." )
      return
    Hanoi(N - 1, from_pos, via_pos, to_pos)
    print( from_pos, " 번 기둥에 있는 원반을 ", to_pos, "번 기둥으로 옮긴다." )
    Hanoi(N - 1, via_pos, to_pos, from_pos)
  ```

- 미로찾기
- 거스름돈

<br/>

## 정렬 알고리즘

- 선택 정렬
  - 선택 정렬 개념
    배열에서 가장 작은 값을 뽑아 새로운 배열에 삽입
    
  - solution1 (의미론적 이해를 돕기 위한 예제)
    ```python
    def find_min_idx(): #가장 작은 수의 인덱스값을 리턴하는 함수
      n = len(a)
      min_idx = 0 //첫번째 수를 가장 작은 수라고 가정
      for i in range(1, n):
        if a[i] < a[min_idx]:
          min_idx = i
      return min_idx
    
    def sel_sort(a): #새로운 배열에 선택 정렬 결과를 만드는 함수
      result = []
      while a:
        min_idx = find_min_idx(a)
        value = a.pop(min_idx)
        result.append(value)
      return result
    ```
    
  - solution2 (swap을 이용한 일반적인 알고리즘)
    ```python
    def sel_sort(a):
      n = len(a)
      for i in range(n-1): #i가 증가하면서 왼쪽 원소부터 비교에서 제외된다
        min_idx = i
        for j in range(i+1, n):
          if a[j] < a[min_idx]:
            min_idx = j
        a[i], a[min_idx] = a[min_idx], a[i]
    ```
- 버블 정렬
  - 버블 정렬 개념
- 삽입 정렬
  - 삽입 정렬 개념
- 병합 정렬
  - 병합 정렬 개념
- 퀵 정렬
  - 퀵 정렬 개념
